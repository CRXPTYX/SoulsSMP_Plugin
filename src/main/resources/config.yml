package com.yourname.soulplugin.managers;

import com.yourname.soulplugin.SoulPlugin;
import com.yourname.soulplugin.enums.SoulRarity;
import com.yourname.soulplugin.enums.SoulType;
import com.yourname.soulplugin.utils.SoulItemCreator;
import org.bukkit.Location;
import org.bukkit.NamespacedKey;
import org.bukkit.entity.Player;
import org.bukkit.inventory.ItemStack;
import org.bukkit.persistence.PersistentDataContainer;
import org.bukkit.persistence.PersistentDataType;

import java.util.*;

public class SoulManager {
    
    private final SoulPlugin plugin;
    private final EffectManager effectManager;
    private final CooldownManager cooldownManager;
    private final NamespacedKey soulKey;
    private final NamespacedKey playerSoulsKey;
    private final NamespacedKey disabledSoulsKey;
    private final NamespacedKey disabledSoulsKey;
    private final Random random;
    private final Map<UUID, Set<SoulType>> playerDisabledSouls;
    private final Map<UUID, Set<SoulType>> playerDisabledSouls;
    
    public SoulManager(SoulPlugin plugin, EffectManager effectManager, CooldownManager cooldownManager) {
        this.plugin = plugin;
        this.effectManager = effectManager;
        this.cooldownManager = cooldownManager;
        this.soulKey = new NamespacedKey(plugin, "soul_type");
        this.playerSoulsKey = new NamespacedKey(plugin, "player_souls");
        this.disabledSoulsKey = new NamespacedKey(plugin, "disabled_souls");
        this.disabledSoulsKey = new NamespacedKey(plugin, "disabled_souls");
        this.random = new Random();
        this.playerDisabledSouls = new HashMap<>();
        this.playerDisabledSouls = new HashMap<>();
    }
    
    public void dropRandomSoul(Location location, Player killedPlayer) {
        SoulType soulType = getRandomSoulType(killedPlayer);
        if (soulType != null) {
            ItemStack soulItem = SoulItemCreator.createSoulItem(soulType, soulKey);
            location.getWorld().dropItemNaturally(location, soulItem);
        }
    }
    
    private SoulType getRandomSoulType(Player player) {
        double roll = random.nextDouble() * 100;
        
        // Filter out disabled souls for this specific player
        Set<SoulType> disabledSouls = getDisabledSoulsForPlayer(player);
        List<SoulType> availableSouls = Arrays.stream(SoulType.values())
            .filter(soul -> soul.getRarity() != SoulRarity.EVENT && !disabledSouls.contains(soul))
            .toList();
        
        if (availableSouls.isEmpty()) {
            return null; // No souls enabled for this player
        }
        
        // Filter out disabled souls for this specific player
        Set<SoulType> disabledSouls = getDisabledSoulsForPlayer(player);
        List<SoulType> availableSouls = Arrays.stream(SoulType.values())
            .filter(soul -> soul.getRarity() != SoulRarity.EVENT && !disabledSouls.contains(soul))
            .toList();
        
        if (availableSouls.isEmpty()) {
            return null; // No souls enabled for this player
        }
        
        // Sort rarities by drop chance (highest first)
        List<SoulRarity> sortedRarities = Arrays.asList(SoulRarity.values());
        sortedRarities.sort((a, b) -> Double.compare(b.getDropChance(), a.getDropChance()));
        
        double cumulativeChance = 0;
        for (SoulRarity rarity : sortedRarities) {
            cumulativeChance += rarity.getDropChance();
            if (roll <= cumulativeChance) {
                // Get random enabled soul of this rarity
                List<SoulType> soulsOfRarity = availableSouls.stream()
                    .filter(soul -> soul.getRarity() == rarity)
                    .toList();
                
                if (!soulsOfRarity.isEmpty()) {
                    return soulsOfRarity.get(random.nextInt(soulsOfRarity.size()));
                }
            }
        }
        
        return null; // No soul dropped
    }
    
    public boolean consumeSoul(Player player, ItemStack item) {
        if (!isSoulItem(item)) {
            return false;
        }
        
        String soulTypeName = item.getItemMeta().getPersistentDataContainer()
            .get(soulKey, PersistentDataType.STRING);
        
        if (soulTypeName == null) {
            return false;
        }
        
        try {
            SoulType soulType = SoulType.valueOf(soulTypeName);
            
            // First, completely clear all existing souls and effects
            clearPlayerSouls(player);
            
            // Then add the new soul
            addSoulToPlayer(player, soulType);
            effectManager.applyPermanentEffects(player);
            
            // Special items for certain souls
            if (soulType == SoulType.DASH) {
                giveDashFeather(player);
            }
            
            player.sendMessage("§7You have consumed a " + soulType.getRarity().getColor() + 
                             soulType.name() + " Soul§7!");
            
            return true;
        } catch (IllegalArgumentException e) {
            return false;
        }
    }
    
    public boolean isSoulItem(ItemStack item) {
        if (item == null || !item.hasItemMeta()) {
            return false;
        }
        
        return item.getItemMeta().getPersistentDataContainer().has(soulKey, PersistentDataType.STRING);
    }
    
    public void addSoulToPlayer(Player player, SoulType soulType) {
        // Only allow one soul at a time - replace any existing soul
        PersistentDataContainer playerData = player.getPersistentDataContainer();
        playerData.set(playerSoulsKey, PersistentDataType.STRING, soulType.name());
    }
    
    public Set<SoulType> getPlayerSouls(Player player) {
        PersistentDataContainer playerData = player.getPersistentDataContainer();
        String soulsString = playerData.get(playerSoulsKey, PersistentDataType.STRING);
        
        Set<SoulType> souls = new HashSet<>();
        if (soulsString != null && !soulsString.isEmpty() && !soulsString.contains(",")) {
            // Only one soul allowed now
            try {
                souls.add(SoulType.valueOf(soulsString));
            } catch (IllegalArgumentException ignored) {
                // Invalid soul type, ignore
            }
        }
        
        return souls;
    }
    
    public void clearPlayerSouls(Player player) {
        player.getPersistentDataContainer().remove(playerSoulsKey);
        effectManager.removePermanentEffects(player);
    }
    
    public boolean hasSoul(Player player, SoulType soulType) {
        return getPlayerSouls(player).contains(soulType);
    }
    
    public boolean isEventSoul(SoulType soulType) {
        return soulType.getRarity() == SoulRarity.EVENT;
    }
    
    private void giveDashFeather(Player player) {
        ItemStack dashFeather = SoulItemCreator.createDashFeather(new NamespacedKey(plugin, "dash_feather"));
        player.getInventory().addItem(dashFeather);
        player.sendMessage("§7You received a §bDash Feather§7! Right-click to dash!");
    }
    
    public CooldownManager getCooldownManager() {
        return cooldownManager;
    }
    
    public EffectManager getEffectManager() {
        return effectManager;
    }
    
    public SoulPlugin getPlugin() {
        return plugin;
    }
    
    // Player-specific soul management methods
    public Set<SoulType> getDisabledSoulsForPlayer(Player player) {
        UUID playerId = player.getUniqueId();
        
    
    // Player-specific soul management methods
    public Set<SoulType> getDisabledSoulsForPlayer(Player player) {
        UUID playerId = player.getUniqueId();
        
        // First check in-memory cache
        if (playerDisabledSouls.containsKey(playerId)) {
            return new HashSet<>(playerDisabledSouls.get(playerId));
        }
        
        // Load from persistent data
        PersistentDataContainer playerData = player.getPersistentDataContainer();
        String disabledSoulsString = playerData.get(disabledSoulsKey, PersistentDataType.STRING);
        
        Set<SoulType> disabledSouls = new HashSet<>();
        if (disabledSoulsString != null && !disabledSoulsString.isEmpty()) {
            String[] soulNames = disabledSoulsString.split(",");
            for (String soulName : soulNames) {
                try {
                    disabledSouls.add(SoulType.valueOf(soulName.trim()));
                } catch (IllegalArgumentException ignored) {
                    // Invalid soul type, ignore
                }
            }
        }
        
        // Cache the result
        playerDisabledSouls.put(playerId, disabledSouls);
        return new HashSet<>(disabledSouls);
    }
    
    public boolean isSoulDisabledForPlayer(Player player, SoulType soulType) {
        return getDisabledSoulsForPlayer(player).contains(soulType);
    }
    
    public void toggleSoulForPlayer(Player player, SoulType soulType) {
        if (soulType.getRarity() == SoulRarity.EVENT) {
            return; // Don't allow toggling event souls
        }
        
        UUID playerId = player.getUniqueId();
        Set<SoulType> disabledSouls = getDisabledSoulsForPlayer(player);
        
        if (disabledSouls.contains(soulType)) {
            disabledSouls.remove(soulType);
        } else {
            disabledSouls.add(soulType);
        }
        
        // Update cache
        playerDisabledSouls.put(playerId, disabledSouls);
        
        // Save to persistent data
        saveDisabledSoulsForPlayer(player, disabledSouls);
    }
    
    public void enableAllSoulsForPlayer(Player player) {
        UUID playerId = player.getUniqueId();
        Set<SoulType> emptySet = new HashSet<>();
        
        // Update cache
        playerDisabledSouls.put(playerId, emptySet);
        
        // Save to persistent data
        saveDisabledSoulsForPlayer(player, emptySet);
    }
    
    public void disableAllSoulsForPlayer(Player player) {
        UUID playerId = player.getUniqueId();
        Set<SoulType> allNonEventSouls = new HashSet<>();
        
        for (SoulType soulType : SoulType.values()) {
            if (soulType.getRarity() != SoulRarity.EVENT) {
                allNonEventSouls.add(soulType);
            }
        }
        
        // Update cache
        playerDisabledSouls.put(playerId, allNonEventSouls);
        
        // Save to persistent data
        saveDisabledSoulsForPlayer(player, allNonEventSouls);
    }
    
    private void saveDisabledSoulsForPlayer(Player player, Set<SoulType> disabledSouls) {
        PersistentDataContainer playerData = player.getPersistentDataContainer();
        
        if (disabledSouls.isEmpty()) {
            playerData.remove(disabledSoulsKey);
        } else {
            StringBuilder sb = new StringBuilder();
            for (SoulType soulType : disabledSouls) {
                if (sb.length() > 0) {
                    sb.append(",");
                }
                sb.append(soulType.name());
            }
            playerData.set(disabledSoulsKey, PersistentDataType.STRING, sb.toString());
        }
    }
}